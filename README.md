# Коллоквиум 4 модуль

# Сеть

## 1. Что такое WebSocket и как он отличается от HTTP? В каких случаях целесообразно использовать WebSocket? Опишите процесс установления WebSocket соединения и его закрытия.

**WebSocket** - это  это коммуникационный протокол, предназначенный для реализации постоянного, двунаправленного соединения между клиентом и сервером (через одно TCP-соединение). В отличие от традиционных HTTP-запросов, которые являются одноразовыми и требуют многократного установления соединения для каждой передачи данных, WebSocket обеспечивает постоянное соединение, что позволяет передавать данные в режиме реального времени.

### Отличия WebSocket от HTTP
Двунаправленность:
- HTTP: Клиент инициирует запрос, сервер отвечает. Это модель запрос-ответ, где каждый обмен данных требует нового HTTP-запроса.
  
- WebSocket: После установления соединения как клиент, так и сервер могут обмениваться данными в любом направлении в любое время без необходимости повторного установления соединения.

Постоянное соединение:
- HTTP: Соединение устанавливается и закрывается для каждого запроса.
  
- WebSocket: Соединение устанавливается один раз и сохраняется до явного закрытия, что позволяет передавать данные с минимальными задержками.

Производительность и масштабируемость:
- HTTP: Каждый запрос содержит заголовки, что увеличивает накладные расходы. Постоянное установление и закрытие соединений также потребляет ресурсы.
  
- WebSocket: Позволяет избежать накладных расходов на установление новых соединений и передачи заголовков, что улучшает производительность, особенно при частом обмене небольшими данными.


### Целесообразность использования WebSocket
WebSocket целесообразно использовать в следующих случаях:

Чат-приложения: Обеспечивает мгновенный обмен сообщениями между пользователями.

Реальное время: Приложения, требующие обновлений в реальном времени, например, финансовые биржи или системы мониторинга.

Онлайн-игры: Обеспечивает низкую задержку и быструю передачу данных между игроками и сервером.

Потоковая передача данных: Потоковая передача мультимедийных данных или данных с датчиков, где важна минимальная задержка.

Коллаборативные приложения: Приложения, где несколько пользователей работают над одним документом в реальном времени.

### Процесс установления WebSocket соединения

1) Инициация соединения:

Клиент отправляет HTTP-запрос с методом GET и заголовком Upgrade, указывающим на желание перейти на протокол WebSocket.

2) Подтверждение от сервера:

Если сервер поддерживает WebSocket и согласен на установление соединения, он отвечает с кодом статуса 101 Switching Protocols, подтверждая обновление протокола.

3) Установление постоянного соединения:

После подтверждения от сервера, соединение считается установленным, и обе стороны могут начинать обмен данными.

### Процесс закрытия WebSocket соединения
1) Инициация закрытия:
Любая сторона (клиент или сервер) может инициировать закрытие соединения, отправив контрольное сообщение с кодом закрытия.

2) Ответное закрытие:
Получив сообщение о закрытии, другая сторона отправляет ответное контрольное сообщение о закрытии.

3) Завершение соединения:
После обмена контрольными сообщениями соединение закрывается, и оба конца освобождают ресурсы, связанные с этим соединением.

### Коды закрытия:

WebSocket поддерживает различные коды закрытия для указания причин закрытия, например:
1000: Нормальное закрытие.
1001: Закрытие по причине ухода пользователя.
1002: Протокольная ошибка.
1003: Неподдерживаемый тип данных.


WebSocket — мощный инструмент для приложений, требующих постоянного обмена данными в реальном времени, благодаря своей способности поддерживать постоянное соединение и двунаправленную коммуникацию.


## 2. Что такое STOMP и как он работает поверх WebSocket? Каковы преимущества использования STOMP? Какие основные команды STOMP вы знаете и для чего они используются?

**STOMP** (Simple Text Oriented Messaging Protocol) — это простой текстовый протокол для обмена сообщениями, который работает поверх различных протоколов транспортного уровня, включая WebSocket, TCP и HTTP

WebSocket протокол не определяет форматы сообщений, поддерживает передачу в текстовом виде и bit. 
Поэтому поверх WebSocket используют другие суб-протоколы, например, STOMP. STOMP чем-то похож на HTTP и работает поверх TCP.

### Как работает STOMP поверх WebSocket?

STOMP поверх WebSocket используется для организации обмена сообщениями в реальном времени. WebSocket обеспечивает транспортный уровень с постоянным соединением, а STOMP добавляет уровень протокола обмена сообщениями, предоставляя набор команд и соглашений для отправки и получения сообщений.

Установление WebSocket соединения:

Клиент устанавливает соединение с сервером, используя WebSocket.
Взаимодействие через STOMP:

STOMP использует текстовые фреймы для передачи команд и сообщений. Каждый фрейм состоит из команды, набора заголовков и тела сообщения (если требуется).
Использование команд STOMP:

Команды STOMP отправляются и принимаются через WebSocket соединение, позволяя клиенту и серверу обмениваться информацией и сообщениями.

STOMP поверх WebSocket используется для организации обмена сообщениями в реальном времени. WebSocket обеспечивает транспортный уровень с постоянным соединением, а STOMP добавляет уровень протокола обмена сообщениями, предоставляя набор команд и соглашений для отправки и получения сообщений.

**Основные шаги работы STOMP поверх WebSocket:**

Установление WebSocket соединения:

Клиент устанавливает WebSocket соединение с сервером.
Инициация STOMP сессии:

После установления WebSocket соединения клиент посылает STOMP команду CONNECT для инициации STOMP сессии.
Отправка и получение сообщений:

Клиент и сервер обмениваются STOMP командами и фреймами сообщений через установленное WebSocket соединение.

**Преимущества использования STOMP**
Простота и читаемость:
STOMP использует текстовые сообщения, что делает его простым для понимания и отладки.

Стандартизация:
STOMP предоставляет стандартные команды и заголовки для обмена сообщениями, что упрощает интеграцию с различными системами и брокерами сообщений.

Поддержка различных транспортных протоколов:
STOMP может работать поверх различных транспортных протоколов, включая WebSocket, TCP и HTTP, обеспечивая гибкость в выборе транспортного уровня.

Функциональность: 
STOMP предоставляет стандартный набор команд для управления сообщениями и подписками, что упрощает реализацию сложных сценариев обмена сообщениями.

### Основные команды STOMP
- CONNECT:
Использование: Устанавливает соединение с сервером STOMP.
![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/d4a1360e-1ed3-4252-a4e0-3e7b6d7140c4)

-CONNECTED
Использование: Ответ сервера на успешный запрос соединения.
![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/05e0a92b-c2a2-46eb-a783-f892b1468f36)


- SEND:
Использование: Отправка сообщения на указанную конечную точку.
![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/72c58f97-23fe-4dcd-9303-6d1f00f54f7f)


- SUBSCRIBE:
Использование: Подписка на указанный канал или очередь для получения сообщений.

![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/67fa3e80-956e-4de4-a5af-eeacccde85fc)


- UNSUBSCRIBE:
Использование: Отмена подписки на указанный канал или очередь.
![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/22e89f8f-e738-40e3-a375-693f73dff279)


- ACK:
Использование: Подтверждение получения сообщения (при использовании подтверждений сообщений).

![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/4c0c47a1-5a59-4e60-9d5f-860e7c44da26)

-NACK:
Использование:Отказ от сообщения (в случаях, когда требуется явное подтверждение).
![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/9d080dde-2c4d-40ef-85ca-f69b6a94294b)

-BEGIN:
Использование: Начало транзакции.
![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/80bc739b-2714-4435-b196-3330c2002a65)

-COMMIT:
Использование: Подтверждение транзакции.
![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/619c8bd2-c571-4156-80aa-bc4ae7e877a2)

- ABORT:
Использование: Отмена транзакции.
![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/9938b19f-2d0c-4e3a-925c-9ece4bcde5b7)


- DISCONNECT:
Использование: Закрытие соединения с сервером STOMP.
![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/fad10961-e8d1-4dc2-bced-1c6c7b7607a8)


- MESSAGE:
Использование: Сообщение, отправляемое сервером клиенту по подписке.


STOMP обеспечивает простой и эффективный способ обмена сообщениями поверх WebSocket, предоставляя стандартный набор команд для управления соединениями, подписками и транзакциями. Использование STOMP поверх WebSocket позволяет создавать мощные приложения реального времени, такие как чаты, онлайн-игры и системы оповещений.

## 3. Дайте определение gRPC. Какие проблемы он решает по сравнению с RESTful API? Опишите основные типы потоковой передачи. Приведите примеры для каждого из них.

**Определение gRPC**
gRPC (gRPC Remote Procedure Calls) — это современный, высокопроизводительный RPC (Remote Procedure Call) фреймворк с открытым исходным кодом, разработанный Google. Он использует HTTP/2 для транспортировки, Protocol Buffers (protobuf) для сериализации сообщений и предоставляет возможности для выполнения функций, таких как потоковая передача данных и двунаправленные соединения.

**Проблемы, решаемые gRPC по сравнению с RESTful API**

**Производительность и эффективность:**

gRPC использует HTTP/2, который поддерживает мультиплексирование, сжатие заголовков и более эффективное использование соединений, что снижает накладные расходы на передачу данных.
REST: Обычно использует HTTP/1.1, который не поддерживает такие возможности, что может привести к более высоким накладным расходам и задержкам.

**Сериализация данных:**

gRPC использует Protocol Buffers (protobuf), который обеспечивает компактную бинарную сериализацию данных, что ускоряет передачу и уменьшает размер сообщений.
REST: Обычно использует текстовые форматы, такие как JSON или XML, которые могут быть менее эффективными по размеру и времени обработки.
**Поддержка различных типов потоковой передачи:**

gRPC поддерживает не только простые запрос-ответ, но и клиентскую и серверную потоковую передачу, а также двунаправленные потоки.
REST: Ограничен паттерном запрос-ответ, что затрудняет реализацию сложных сценариев обмена данными в реальном времени.
**Инструменты и генерация кода:**

gRPC предоставляет автоматическую генерацию кода для клиентов и серверов на различных языках программирования, что облегчает разработку и уменьшает вероятность ошибок.
REST: Требует ручной разработки кода для обработки HTTP-запросов и ответов, что может быть более трудоемким и подверженным ошибкам процессом.

**Основные типы потоковой передачи в gRPC**
1. Unary RPC:

Обычный запрос-ответ, при котором клиент отправляет один запрос и получает один ответ от сервера.
![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/d2761b28-546b-4a9e-b9e8-fba9f05d172e)

2. Server Streaming RPC:

Клиент отправляет один запрос серверу и получает поток ответов.

service ExampleService {
  rpc ServerStreamingCall(RequestMessage) returns (stream ResponseMessage);
}

3. Client Streaming RPC:

Клиент отправляет поток запросов серверу и получает один ответ от сервера.

service ExampleService {
  rpc ClientStreamingCall(stream RequestMessage) returns (ResponseMessage);
}

4. Bidirectional Streaming RPC:

Клиент и сервер обмениваются потоками сообщений. Обе стороны могут читать и писать сообщения в любой момент времени.

service ExampleService {
  rpc BidiStreamingCall(stream RequestMessage) returns (stream ResponseMessage);
}

**Примеры использования каждого типа потоковой передачи**

![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/c3ff38e3-e54d-414a-8a07-7b13769e438c)

![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/4f57150e-6514-4d2e-a207-be46d16f3c8a)

![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/a3c0beff-b268-4b39-a972-445d08e16545)

![image](https://github.com/JuliaArbuzova/Kollok_KPO/assets/154761916/dae714be-6a4a-4c16-b981-16afa6c670e8)

gRPC предлагает мощный и эффективный способ реализации RPC, решая многие проблемы RESTful API, такие как производительность и поддержка сложных сценариев обмена данными в реальном времени. Различные типы потоковой передачи в gRPC позволяют гибко подходить к различным задачам, от простых запросов до сложных двунаправленных потоков.

## 4. Протоколы прикладного уровня: HTTP/1.1 и HTTP/2. Где используются? 

### Что такое HTTP?

**HTTP (HyperText Transfer Protocol)** — это протокол передачи данных в интернете. Изначально для передачи данных в виде гипертекстовых документов в формате HTML, сегодня — для передачи произвольных данных.

### Разница между HTTP/1.1 и HTTP/2

**HTTP/1.1** был стандартом для передачи данных в Интернете на протяжении многих лет, но он имеет ряд ограничений, которые могут снижать производительность и масштабируемость веб-приложений. **HTTP/2** был разработан для устранения этих ограничений и предлагает ряд улучшений:

- Множественные потоки: В **HTTP/1.1** каждый запрос обрабатывается последовательно, что может привести к задержкам, особенно в условиях высокой загрузки. **HTTP/2** позволяет обрабатывать несколько запросов одновременно в рамках одного соединения, что улучшает производительность.
- Сжатие заголовков: **HTTP/1.1** требует отправку заголовков для каждого запроса, что может быть неэффективным, особенно если заголовки остаются неизменными между запросами. **HTTP/2** использует сжатие заголовков для уменьшения объема передаваемых данных.
- Приоритизация запросов: В **HTTP/1.1** запросы обрабатываются в порядке их поступления, что может привести к задержкам для менее важных запросов. **HTTP/2** позволяет клиенту указывать приоритеты запросов, чтобы сервер мог обрабатывать более важные запросы первыми.
- Серверный пуш: **HTTP/2** вводит концепцию серверного пуша, позволяя серверу активно отправлять данные клиенту без предварительного запроса. Это может улучшить время загрузки веб-страниц, отправляя данные заранее.
- Бинарный протокол: В отличие от **HTTP/1.1**, который использует текстовый протокол, **HTTP/2** является бинарным протоколом. Это упрощает обработку и уменьшает объем передаваемых данных.

**HTTP/2** был разработан для улучшения производительности и масштабируемости веб-приложений, устраняя некоторые из ограничений **HTTP/1.1**. Однако, несмотря на эти улучшения, **HTTP/2** требует поддержки со стороны клиента и сервера, и не все клиенты и серверы могут поддерживать **HTTP/2**.


## 5. Протоколы транспортного уровня: TCP, UDP. Где используются?

**TCP (Transmission Control Protocol)** 

- Протокол надежной и упорядоченной доставки данных
- Обеспечивает контроль передачи данных, управление потоком, обнаружение ошибок и повторную передачу данных при необходимости

**UDP (User Datagram Protocol)**

- Простой протокол без гарантии доставки данных, контроля потока или механизмов повторной передачи данных
- Представляет собой менее надежную альтернативу TCP

### Разница между TCP и UDP

- **Надежность:** TCP обеспечивает надежную передачу данных, используя механизмы подтверждения получения, повторной передачи потерянных пакетов и контроля потока. UDP не предоставляет таких гарантий, что делает его более подходящим для приложений, где скорость важнее надежности, например, в потоковом видео или игровых приложениях
- **Соединение:** TCP использует соединение для обмена данными между отправителем и получателем, что обеспечивает упорядоченную и безошибочную передачу. UDP не использует соединение, что позволяет ему быстрее передавать данные, но также означает, что он не может гарантировать упорядоченность или доставку данных
- **Заголовки:** TCP заголовки содержат больше информации, чем UDP заголовки, включая номера последовательности, контрольные суммы и флаги управления соединением. UDP заголовки значительно меньше и содержат только порты отправителя и получателя
- **Применение:** TCP часто используется в приложениях, где важна надежность и целостность данных, таких как веб-сервисы, электронная почта и файловые передачи. UDP часто используется в приложениях, где скорость важнее, и потеря некоторых пакетов приемлема, например, в потоковом видео, онлайн-играх и VoIP



# Тестирование + Kafka

## 1. Что такое Kafka? Какие проблемы она решает?

Apache Kafka — это распределённая платформа для потоковой передачи данных с высокой пропускной способностью, разработанная для публикации, подписки, хранения и обработки потоков записей в реальном времени. Kafka была разработана LinkedIn и передана в Apache Software Foundation, где она теперь является проектом с открытым исходным кодом.

**Основные компоненты Kafka**
Продюсеры (Producers): Отправляют данные в Kafka.
Консюмеры (Consumers): Получают данные из Kafka.
Брокеры (Brokers): Узлы, которые хранят данные и обрабатывают запросы.
Топики (Topics): Категории или каналы, к которым продюсеры отправляют данные, а консюмеры подписываются на них.
Партиции (Partitions): Топики разбиваются на более мелкие части для масштабирования и балансировки нагрузки.
Зоопаркипер (ZooKeeper): Используется для управления и координации брокеров (начиная с версии 2.8, ZooKeeper постепенно заменяется на внутренний консенсусный механизм Kafka - KRaft).
Проблемы, решаемые Kafka
Высокопроизводительная передача данных:

Kafka обеспечивает высокую пропускную способность для обработки огромного количества данных в реальном времени, что особенно важно для крупных систем с большим количеством пользователей и взаимодействий.
Надёжность и отказоустойчивость:

Благодаря репликации данных между брокерами, Kafka обеспечивает высокую надёжность и устойчивость к сбоям.
Масштабируемость:

Kafka легко масштабируется путем добавления новых брокеров и партиций, что позволяет поддерживать увеличение объёма данных и количества запросов.
Очереди сообщений и потоки событий:

Kafka объединяет возможности традиционных систем очередей сообщений и логов событий, позволяя как временное хранение сообщений, так и обработку потоков данных.
Реальное время и аналитика:

Kafka используется для обработки и анализа данных в реальном времени, что делает её идеальной для мониторинга систем, финансовых торговых платформ и других приложений, требующих немедленной реакции на события.
Примеры использования Kafka
Логирование и отслеживание событий:

Системы логирования, такие как ELK stack (Elasticsearch, Logstash, Kibana), используют Kafka для сбора и передачи логов из различных источников.
Обработка и анализ данных в реальном времени:

Финансовые компании используют Kafka для анализа биржевых котировок и других финансовых данных в реальном времени.
Мониторинг и оповещения:

Системы мониторинга, такие как Prometheus и Grafana, могут использовать Kafka для передачи метрик и событий мониторинга.
ETL процессы (Extract, Transform, Load):

Kafka используется для передачи данных между различными системами, обеспечивая высокую скорость и надёжность.
Микросервисная архитектура:

В микросервисных архитектурах Kafka служит в качестве центрального узла для обмена сообщениями между сервисами, улучшая масштабируемость и отказоустойчивость системы.
Заключение
Apache Kafka предоставляет мощную и масштабируемую платформу для обработки потоков данных в реальном времени, решая проблемы высокой пропускной способности, надёжности и отказоустойчивости. Она широко используется в различных областях, от логирования и мониторинга до сложных аналитических систем, благодаря своей гибкости и производительности.

## 2. Из каких основных частей состоит кафка? Кратко опишите каждый и какую задачу решает.

Apache Kafka состоит из нескольких основных компонентов, каждый из которых выполняет специфическую задачу для обеспечения общей функциональности системы. Вот основные части Kafka и их описание:

Основные части Kafka
Топики (Topics):

Описание: Логические каналы, по которым организуются сообщения. Каждый топик имеет уникальное имя и разделяется на партиции.
Задача: Организация и категоризация сообщений для продюсеров и консюмеров. Топики позволяют различным потокам данных быть изолированными друг от друга.
Партиции (Partitions):

Описание: Топики разбиваются на партиции для увеличения параллелизма и масштабируемости. Каждая партиция представляет собой упорядоченный и неизменяемый лог сообщений.
Задача: Балансировка нагрузки и повышение производительности. Партиции позволяют сообщениям обрабатываться параллельно разными консюмерами, увеличивая общую пропускную способность системы.
Продюсеры (Producers):

Описание: Клиенты, которые публикуют сообщения в топики.
Задача: Отправка данных в Kafka. Продюсеры могут распределять сообщения по партициям внутри топика на основе различных стратегий, таких как хеширование ключа сообщения или круговая схема (round-robin).
Консюмеры (Consumers):

Описание: Клиенты, которые подписываются на топики и читают сообщения.
Задача: Получение данных из Kafka. Консюмеры могут объединяться в группы, где каждая группа координирует потребление сообщений из партиций, обеспечивая параллельную обработку данных.
Брокеры (Brokers):

Описание: Узлы в кластере Kafka, которые хранят данные и обрабатывают запросы продюсеров и консюмеров.
Задача: Управление хранением, получение и передачей сообщений. Брокеры обеспечивают репликацию данных для надёжности и отказоустойчивости.
Кластер Kafka:

Описание: Совокупность нескольких брокеров, работающих вместе.
Задача: Обеспечение масштабируемости и отказоустойчивости. В кластере данные реплицируются между брокерами, что повышает надёжность системы.
ZooKeeper:

Описание: Центральный координационный сервис для управления и синхронизации брокеров Kafka (начиная с версии 2.8, Kafka переходит на внутренний механизм координации под названием KRaft).
Задача: Управление метаданными кластера Kafka, такими как информация о топиках, партициях и лидерах партиций. ZooKeeper обеспечивает отказоустойчивость и координацию между брокерами.
Лидеры и Реплики (Leaders and Replicas):

Описание: В каждой партиции один брокер является лидером, а остальные — репликами.
Задача: Лидер отвечает за все операции записи и чтения для своей партиции, а реплики поддерживают копии данных лидера для повышения отказоустойчивости. В случае сбоя лидера, одна из реплик становится новым лидером.
Заключение
Apache Kafka предоставляет мощную платформу для потоковой передачи данных в реальном времени благодаря своей архитектуре, включающей топики, партиции, продюсеров, консюмеров, брокеров и координационные сервисы, такие как ZooKeeper. Эти компоненты вместе обеспечивают высокую производительность, масштабируемость и надёжность системы, делая её идеальным выбором для обработки больших объёмов данных в реальном времени.

## 3. Что такое schema registry. В чём суть? Как она работает?

Что такое Schema Registry?
Schema Registry (регистрация схем) — это сервис для хранения и управления схемами данных. Обычно используется в контексте систем потоковой передачи данных, таких как Apache Kafka, для обеспечения совместимости данных и управления версиями схем. Одним из наиболее популярных решений для работы с схемами является Confluent Schema Registry, который часто используется вместе с Apache Kafka.

Суть Schema Registry
Основная цель Schema Registry — это управление и проверка схем, чтобы обеспечить согласованность данных, которые передаются между различными компонентами системы. Схема определяет структуру данных, например, формат сообщений, которые продюсеры отправляют и консюмеры получают.

Как работает Schema Registry
Регистрация схем:

Продюсеры и консюмеры взаимодействуют со Schema Registry для регистрации и получения схем.
Продюсер отправляет схему в Schema Registry перед отправкой данных. Schema Registry сохраняет схему и возвращает уникальный идентификатор (ID) схемы.
Пример регистрации схемы

**{
  "type": "record",
  "name": "User",
  "fields": [
    {"name": "name", "type": "string"},
    {"name": "age", "type": "int"}
  ]
}
**

Сериализация данных:

Перед отправкой данных в Kafka, продюсер сериализует данные с использованием зарегистрированной схемы. Обычно сериализатор добавляет идентификатор схемы к сериализованным данным.
Пример сериализованных данных с ID схемы: [schema_id | serialized_data].
Десериализация данных:

Консюмер, получив сообщение из Kafka, использует идентификатор схемы для запроса соответствующей схемы из Schema Registry.
После получения схемы консюмер десериализует данные, используя эту схему, и интерпретирует их.
Совместимость схем:

Schema Registry поддерживает политику совместимости, определяющую, как схемы могут эволюционировать. Основные типы совместимости включают:
Backward Compatibility: Новая схема должна быть совместима с ранее зарегистрированными схемами. Консюмеры, использующие старые схемы, могут читать данные, записанные с новой схемой.
Forward Compatibility: Старые схемы должны быть совместимы с новой схемой. Консюмеры, использующие новую схему, могут читать данные, записанные со старыми схемами.
Full Compatibility: Комбинация обратной и прямой совместимости. Новая схема должна быть совместима как с предыдущими, так и с будущими схемами.
Преимущества использования Schema Registry
Гарантированная совместимость данных:

Обеспечивает уверенность в том, что изменения в структуре данных не нарушат существующие системы.
Управление версиями схем:

Позволяет отслеживать и управлять различными версиями схем, упрощая эволюцию данных.
Централизованное управление:

Предоставляет единое хранилище для всех схем, упрощая управление и доступ.
Улучшенная сериализация и десериализация:

Схемы позволяют эффективно сериализовать и десериализовать данные, что повышает производительность системы.

Пример использования Schema Registry с Kafka
Регистрация схемы:

Продюсер регистрирует схему в Schema Registry:
curl -X POST -H "Content-Type: application/vnd.schemaregistry.v1+json" \
--data '{"schema": "{\"type\":\"record\",\"name\":\"User\",\"fields\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"age\",\"type\":\"int\"}]}"}' \
http://localhost:8081/subjects/User-value/versions

Отправка данных:

Продюсер сериализует данные с использованием зарегистрированной схемы и отправляет их в Kafka.
Получение данных:

Консюмер запрашивает схему по идентификатору, полученному вместе с данными, и десериализует данные, используя эту схему.

Schema Registry играет ключевую роль в системах потоковой передачи данных, обеспечивая согласованность и совместимость данных. Он позволяет управлять эволюцией схем, улучшает процессы сериализации и десериализации, а также упрощает централизованное управление структурами данных. Это делает его важным инструментом в экосистеме Apache Kafka и других подобных системах.


## 4. Что такое unit-тестирование и какова его цель? 

**Unit-тестирование (модульное тестирование)** —  это метод тестирования программного обеспечения, при котором отдельные компоненты (модули) программы проверяются на корректность их работы. Каждый модуль, обычно это отдельная функция или метод, тестируется изолированно от других частей системы. Целью unit-тестирования является проверка того, что каждый модуль программы работает правильно и соответствует заданным требованиям.

### Цель:
- Найти дефекты в компонентах (классы/модули/функции)
- Сформировать уверенность (на каком-то уровне), что компонент
работает
- Заложить базу для следующих уровней тестирования
- Обеспечение корректной работы отдельных частей системы
- Документирование поведения кода: Unit-тесты могут служить дополнительной документацией, показывая, как должны работать функции или методы, и какие результаты ожидать при различных входных данных.
- Поддержка рефакторинга кода (Наличие unit-тестов позволяет безопасно изменять и улучшать код, обеспечивая уверенность в том, что изменения не привнесут новых ошибок и не нарушат существующую функциональность.)
- Улучшение архитектуры и проектирования кода (оскольку модульное тестирование требует изоляции компонентов, это стимулирует разработчиков писать более модульный и чистый код с чётко определёнными интерфейсами.)

Объекты тестирования: 
- Классы
- Компоненты, модули

Типичные ошибки/дефекты:
- Проблемы с потоком данных и потоком управления
- Неверная логика
- Не вписываемся в требования

Пример кода
// MathOperations.kt
package com.example

class MathOperations {
    fun add(a: Int, b: Int): Int {
        return a + b
    }

    fun subtract(a: Int, b: Int): Int {
        return a - b
    }
}

Unit тесты
// MathOperationsTest.kt
package com.example

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class MathOperationsTest {

    private val mathOperations = MathOperations()

    @Test
    fun testAdd() {
        assertEquals(3, mathOperations.add(1, 2))
        assertEquals(0, mathOperations.add(-1, 1))
        assertEquals(-2, mathOperations.add(-1, -1))
    }

    @Test
    fun testSubtract() {
        assertEquals(1, mathOperations.subtract(2, 1))
        assertEquals(-2, mathOperations.subtract(-1, 1))
        assertEquals(0, mathOperations.subtract(-1, -1))
    }
}




  Unit-тестирование — это важный этап разработки программного обеспечения, который помогает обеспечить качество кода, упростить процесс разработки, поддерживать и улучшать архитектуру программы. Оно играет ключевую роль в процессе обнаружения ошибок на ранних стадиях и поддерживает уверенность разработчиков в корректности их кода.

## 5. Что такое mock-объект? Зачем он нужен? Какая разница с stub-объектом? В каких случаях стоит использовать mock-объект?

Что такое mock-объект?
Mock-объект — это объект, поведение которого имитируется (mock) для целей тестирования. Такие объекты позволяют эмулировать поведение реальных объектов в контролируемых условиях, что облегчает тестирование кода. Mock-объекты могут настраиваться для возврата определенных значений и проверки вызовов методов, что позволяет тестировать взаимодействие между компонентами системы.

Зачем нужен mock-объект?
Mock-объекты используются для:

Изоляции тестов: Тестируемый код может зависеть от других компонентов или внешних систем (например, баз данных, веб-сервисов), и mock-объекты позволяют изолировать тестируемую часть, устраняя влияние этих зависимостей.
Контролируемого поведения: Mock-объекты можно настраивать так, чтобы они возвращали нужные значения и проверяли, что определенные методы были вызваны.
Повышения скорости тестирования: При использовании mock-объектов нет необходимости выполнять реальные операции (например, запросы к базе данных), что ускоряет выполнение тестов.
Тестирования ошибок и исключений: С помощью mock-объектов можно легко моделировать ситуации, когда внешние компоненты ведут себя неправильно или бросают исключения.
Разница между mock и stub объектами
Stub-объект (заглушка): Stub-объект используется для предоставления предопределенных ответов на вызовы его методов. Он служит для того, чтобы тестируемый код мог работать, не обращаясь к реальным зависимостям. Stub-объекты не проверяют, какие методы были вызваны, и не следят за взаимодействием.

Mock-объект: Mock-объект, помимо предоставления предопределенных ответов, также отслеживает, какие методы были вызваны, в каком порядке и с какими параметрами. Это позволяет проверять взаимодействие между компонентами.

Примеры использования mock-объектов
Для примеров на Kotlin мы будем использовать библиотеку Mockito Kotlin.
Пример использования mock-объекта:

import org.junit.Test
import org.mockito.kotlin.*

class UserServiceTest {

    @Test
    fun `test getUser returns user data`() {
        // Создаем mock-объект для UserRepository
        val userRepository: UserRepository = mock()

        // Задаем поведение mock-объекта
        whenever(userRepository.getUser(any())).thenReturn(User("John Doe"))

        // Создаем экземпляр UserService, используя mock UserRepository
        val userService = UserService(userRepository)

        // Вызываем метод getUser
        val user = userService.getUser("user-id-123")

        // Проверяем результат
        assert(user.name == "John Doe")

        // Проверяем, что метод getUser был вызван с нужным параметром
        verify(userRepository).getUser("user-id-123")
    }
}

interface UserRepository {
    fun getUser(userId: String): User?
}

class UserService(private val userRepository: UserRepository) {
    fun getUser(userId: String): User? {
        return userRepository.getUser(userId)
    }
}

data class User(val name: String)


Что такое mock-объект?
Mock-объект — это объект, поведение которого имитируется (mock) для целей тестирования. Такие объекты позволяют эмулировать поведение реальных объектов в контролируемых условиях, что облегчает тестирование кода. Mock-объекты могут настраиваться для возврата определенных значений и проверки вызовов методов, что позволяет тестировать взаимодействие между компонентами системы.

Зачем нужен mock-объект?
Mock-объекты используются для:

Изоляции тестов: Тестируемый код может зависеть от других компонентов или внешних систем (например, баз данных, веб-сервисов), и mock-объекты позволяют изолировать тестируемую часть, устраняя влияние этих зависимостей.
Контролируемого поведения: Mock-объекты можно настраивать так, чтобы они возвращали нужные значения и проверяли, что определенные методы были вызваны.
Повышения скорости тестирования: При использовании mock-объектов нет необходимости выполнять реальные операции (например, запросы к базе данных), что ускоряет выполнение тестов.
Тестирования ошибок и исключений: С помощью mock-объектов можно легко моделировать ситуации, когда внешние компоненты ведут себя неправильно или бросают исключения.
Разница между mock и stub объектами
Stub-объект (заглушка): Stub-объект используется для предоставления предопределенных ответов на вызовы его методов. Он служит для того, чтобы тестируемый код мог работать, не обращаясь к реальным зависимостям. Stub-объекты не проверяют, какие методы были вызваны, и не следят за взаимодействием.

Mock-объект: Mock-объект, помимо предоставления предопределенных ответов, также отслеживает, какие методы были вызваны, в каком порядке и с какими параметрами. Это позволяет проверять взаимодействие между компонентами.

Примеры использования mock-объектов
Для примеров на Kotlin мы будем использовать библиотеку Mockito Kotlin.

Пример использования mock-объекта:
kotlin
Copy code
import org.junit.Test
import org.mockito.kotlin.*

class UserServiceTest {

    @Test
    fun `test getUser returns user data`() {
        // Создаем mock-объект для UserRepository
        val userRepository: UserRepository = mock()

        // Задаем поведение mock-объекта
        whenever(userRepository.getUser(any())).thenReturn(User("John Doe"))

        // Создаем экземпляр UserService, используя mock UserRepository
        val userService = UserService(userRepository)

        // Вызываем метод getUser
        val user = userService.getUser("user-id-123")

        // Проверяем результат
        assert(user.name == "John Doe")

        // Проверяем, что метод getUser был вызван с нужным параметром
        verify(userRepository).getUser("user-id-123")
    }
}

interface UserRepository {
    fun getUser(userId: String): User?
}

class UserService(private val userRepository: UserRepository) {
    fun getUser(userId: String): User? {
        return userRepository.getUser(userId)
    }
}

data class User(val name: String)
**Пример использования stub-объекта:**

class UserServiceStubTest {

    @Test
    fun `test getUser returns user data`() {
        // Создаем stub-объект для UserRepository
        val userRepository = StubUserRepository()

        // Создаем экземпляр UserService, используя stub UserRepository
        val userService = UserService(userRepository)

        // Вызываем метод getUser
        val user = userService.getUser("user-id-123")

        // Проверяем результат
        assert(user?.name == "Stub User")
    }
}

class StubUserRepository : UserRepository {
    override fun getUser(userId: String): User? {
        return User("Stub User")
    }
}


Когда использовать mock-объект?
Mock-объекты стоит использовать в следующих случаях:

Когда необходимо проверить взаимодействие между объектами, а не только результат выполнения метода.
Когда внешний компонент трудно или невозможно использовать в тестах (например, удаленный сервис, медленная база данных).
Когда требуется эмулировать сложные сценарии поведения и ошибок для проверки корректной обработки исключений и других нетипичных ситуаций.
Использование mock-объектов делает тестирование более гибким и позволяет сфокусироваться на логике взаимодействия между компонентами, что особенно важно для модульного тестирования.

## 6. Что такое интеграционное тестирование? Объясните разницу между unit-тестами и интеграционными тестами.

**Интеграционное тестирование** — это процесс тестирования взаимодействия между различными модулями или компонентами системы. Целью интеграционного тестирования является выявление дефектов в интерфейсах и взаимодействиях между интегрируемыми частями системы.

Цель: 
- Найти сбои в взаимодействии разных интерфейсов
- Сформировать уверенность в качестве интерфейсов (на каком-то уровне)
- Избежать ошибок на уровнях выше
- Найти дефекты нижнего уровня

### Разница между unit-тестами и интеграционными тестами
- Цель тестирования:
Unit-тесты: Проверяют корректность работы отдельных модулей или функций в изоляции от других частей системы.
Интеграционные тесты: Проверяют взаимодействие и интеграцию нескольких модулей или компонентов системы.

- Уровень изоляции:
Unit-тесты: Высокий уровень изоляции. Тестируемый код изолирован от зависимостей с помощью mock-объектов или заглушек.
Интеграционные тесты: Низкий уровень изоляции. Тестируемые модули взаимодействуют с реальными зависимостями или с частями системы, которые максимально приближены к реальным.

- Область покрытия:
Unit-тесты: Покрывают небольшие части кода (отдельные методы или классы).
Интеграционные тесты: Покрывают взаимодействие между модулями, могут охватывать большие части системы.

- Пример использования:
Unit-тесты: Проверка, что метод calculateSum() возвращает правильный результат.
Интеграционные тесты: Проверка, что модуль обработки платежей корректно взаимодействует с модулем базы данных и внешним API.

- Время выполнения:
Unit-тесты: Обычно выполняются быстро, так как изолированы и не требуют запуска всей системы.
Интеграционные тесты: Могут выполняться дольше, так как требуют настройки и взаимодействия с внешними системами или другими частями приложения.

# Безопасность

## 1. Дайте определение понятиям идентификации, аутентификации и авторизации. В чем различие между ними?

**Идентификация** – это процедура распознавания пользователя по еголичному идентификатору. (Кто пользователь?)

**Аутентификация** – процедура проверки подлинности, например: проверка подлинности пользователя путём сравнения введённого им пароля с паролем, сохранённым в базе данных пользовательских логинов. 
(Действительно ли это наш пользователь?)

**Авторизация** – предоставление определённому лицу или группе лиц прав навыполнение определённых действий; а также процесс проверки данных правпри попытке выполнения этих действий.
(К чему есть доступ у этого пользователя?)


## 2. Что такое password-based authentication и какие у нее есть преимущества и недостатки? Объясните, как работает протокол HTTP Basic Authentication.

**Аутентификация по паролю**
Метод аутентификации, который основывается на том, что пользователь должен предоставить логин и пароль для идентификации, а далее для аутентификации. 
Логин и пароль задаются пользователем при регистрации в системе. При использовании этого метода система проверяет, совпадают ли предоставленные учетные данные с сохраненными учетными записями в системе.

**Преимущества password-based authentication:**
- Простота использования: Для пользователей удобно запоминать и использовать пароли.
- Широкое распространение: Этот метод широко используется и поддерживается многими системами и сервисами.
- Относительная стойкость: При использовании достаточно длинных и сложных паролей, этот метод может обеспечить приемлемый уровень безопасности.
- 
**Недостатки password-based authentication:**
- Уязвимость к атакам перебора: Если пароли слишком просты или коротки, они могут быть взломаны атаками перебора.
- Уязвимость к перехвату и атакам посередине: При передаче паролей по незашифрованным каналам они могут быть перехвачены и использованы злоумышленниками.
- Проблемы с безопасностью пароля: Пользователи могут использовать слабые или повторяющиеся пароли, что делает систему уязвимой к атакам.

### HTTP Basic Authentication
1. Клиент хочет аутентифицироваться (отправляет GET-запрос)
2. Сервер отвечает с кодом ошибки 401 (Unathorized), а также отправляет какуюто информацию (realm) в response headere WWW-Authenticate
3. Клиент отправляет на сервер запрос сrequest header-ом Authorization (в котором находятся необходимые для авторизации данные, закодированные в Base64).

![alt text](https://github.com/kkkkkostya/kpo_kollok/blob/8ce6d8e1994a7cdca204aa0b1dc6df8a8b4565dc/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-06-12%20153948.png)

## 3. Что такое аутентификация по токенам? Приведите пример flow такого способа аутентификации.

**Аутентификация по токенам** - это метод аутентификации, при котором клиент получает уникальный токен после успешной аутентификации, который затем используется для подтверждения своей личности при доступе к защищенным ресурсам или при выполнении запросов в системе. Токен является временным, одноразовым или долговременным ключом, который обычно содержит информацию о пользователе, правах доступа и сроке действия.

###Пример flow аутентификации по токенам:
- Аутентификация: Пользователь предоставляет свои учетные данные (логин и пароль) для аутентификации.

- Генерация токена: После успешной аутентификации сервер генерирует уникальный токен для пользователя.

- Отправка токена клиенту: Токен отправляется клиенту, например, в виде JSON Web Token (JWT), который может быть включен в ответ сервера или отправлен в виде cookie или заголовка ответа.

- Хранение токена: Клиент хранит полученный токен в безопасном месте, например, в памяти приложения или в localStorage браузера.

- Предоставление токена при доступе к ресурсам: При каждом запросе клиент предоставляет токен серверу, обычно путем включения его в заголовок Authorization или отправки его в виде cookie.

- Проверка токена на сервере: Сервер проверяет полученный токен на валидность, аутентифицирует пользователя и разрешает доступ к запрашиваемым ресурсам или выполняемым операциям.

- Обновление токена (при необходимости): Если токен имеет ограниченное время действия, клиент может запросить обновление токена, предоставив свой текущий токен, и сервер может сгенерировать новый токен с обновленным сроком действия.

- Завершение сеанса: Пользователь может выйти из системы, в результате чего токен становится недействительным, и доступ к защищенным ресурсам больше не разрешается.

## 4. Что такое JSON Web Token? Из каких основных частей формируется данный токен?

**JSON Web Token (JWT)** — содержит три блока, разделенных точками: заголовок, набор полей (claims) и подпись. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие). Подпись может генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.

Пример подписанного JWT токена (после декодирования 1 и 2 блоков).\ 
{ «alg»: «HS256», «typ»: «JWT» }. \
{ «iss»: «auth.myservice.com», «aud»: «myservice.com», «exp»: «1435937883», «userName»: «John Smith», «userRole»: «Admin» }. \
S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY


## 5. Объясните разницу между access-токенами и refresh-токенами (и id-токеном?). Как происходит обновление access-токена с использованием refresh-токена?

**Access-токен** - это токен, который предоставляет клиенту доступ к защищенным ресурсам или API. Он содержит информацию об объеме прав и доступе, а также может иметь ограниченный срок действия.
**Refresh-токен** - это токен, который используется для получения нового access-токена после истечения срока его действия. Он обычно имеет более длительный срок действия по сравнению с access-токеном.
**ID-токен** - это токен, который содержит информацию о пользователе, такую как его идентификатор, имя, email и другие атрибуты

**Обновление access-токена:**
- Клиент отправляет refresh-токен серверу.
- Сервер проверяет refresh-токен и выдает новый access-токен.

## 6. Объясните, как работают фильтры безопасности (security filters) в Spring Security и приведите примеры их использования. Как настроить аутентификацию с использованием JWT в Spring Security?

**Фильтры безопасности в Spring Security** — это компоненты, которые обрабатывают входящие HTTP-запросы и выполняют задачи аутентификации, авторизации и других аспектов безопасности до того, как запрос достигнет контроллера. Эти фильтры находятся в цепочке фильтров (filter chain), и каждый фильтр выполняет определенную функцию.

**Примеры использования фильтров безопасности:**
- BasicAuthenticationFilter: Обрабатывает HTTP Basic Authentication.
- UsernamePasswordAuthenticationFilter: Обрабатывает аутентификацию с использованием имени пользователя и пароля.
- JWTAuthenticationFilter: Проверяет наличие JWT в заголовках запросов и валидирует его.
- SecurityContextPersistenceFilter: Сохраняет и восстанавливает SecurityContext между запросами.

### Пример настройки аутентификации с использованием JWT в Spring Security

